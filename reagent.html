<!DOCTYPE html>
<html><head>
  <meta charset="UTF-8"/>
  <title>mreframe/reagent: Minimalistic Mithril for JavaScript</title>
  <link rel="stylesheet" href="tutorial/style.css"/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script> <!-- used in some examples -->
  <script src="dist/mreframe.js"></script>
  <script src="tutorial/reagent.examples.js"></script> <!-- example sources & pre-generated code highlights -->
  <script src="tutorial/reagent.js"></script> <!-- SPA script -->
</head><body>
<nav><ul class="nav">
 <li><a href="https://lexofleviafan.github.io/mreframe" title="mreframe (&quot;Mithril + re-frame&quot;)" target="_blank">mreframe</a></li>
<li><a href="https://reagent-project.github.io" title="Reagent (CLJS)" target="_blank">[Reagent]</a></li>
<li><a href="re-frame.html" title="re-frame" target="_blank">re-frame</a></li>
<li class="separator"></li>
<li class=""><a title="Display HTML code examples">HTML</a></li>
<li class="brand"><a title="Display JS code examples">JS</a></li>
<li class=""><a title="Display Coffee code examples">Coffee</a></li>
<li class=""><a title="Display Wisp code examples">Wisp</a></li>
</ul></nav>

<main>

<h1><del>Reagent</del> <code>mreframe/reagent</code>: Minimalistic <del>React</del> Mithril for <del>ClojureScript</del> JavaScript</h1>
<p><strong>Note: This is a repurposed copy of the <a href="https://reagent-project.github.io" target="_blank">original tutorial for Reagent (a React/ClojureScript library)</a></strong></p>


<h2 id="introduction-to-reagent">Introduction to Reagent</h2>
<p><a href="https://github.com/LeXofLeviafan/mreframe/blob/main/docs/reagent.md" target="_blank"><code>mreframe/reagent</code></a> provides a minimalistic interface
 for <a href="https://mithril.js.org" target="_blank">Mithril</a>. It allows you to define efficient React components using nothing but
 plain JavaScript functions and data, that describe your UI using a <a href="https://github.com/weavejester/hiccup" target="_blank">Hiccup</a>-like syntax.</p>
<p>The goal of Reagent is to make it possible to define arbitrarily complex UIs using just a couple of basic concepts,
 and to be fast enough by default that you rarely have to think about performance.</p>
<p>A very basic Reagent component may look something like this:</p>

<h3 class="example-heading">Example<a class="example-hide">hide</a></h3>
<div id="simple-component" class="example simple"><div>
  <p>I am a component!</p>
  <p class="someclass">
    I have <strong>bold</strong><span style="color:red"> and red </span>text.
  </p>
</div></div>
<h3 class="source-heading simple">Source<span class="source-lang">JS</span></h3>
<pre class="source simple"><code class="language-js">let simpleComponent = () =&gt;
  ['div',
    ['p', "I am a component!"],
    ['p.someclass',
      "I have ", ['strong', "bold"],
      ['span', {style: {color: 'red'}}, " and red "], "text."]];</code></pre>

<p>You can build new components using other components as building blocks. Like this:</p>

<h3 class="example-heading">Example<a class="example-hide">hide</a></h3>
<div id="simple-parent" class="example simple"><div>
  <p>I include simpleComponent.</p>
  <div>
    <p>I am a component!</p>
    <p class="someclass">
      I have <strong>bold</strong><span style="color:red"> and red </span>text.
    </p>
  </div>
</div></div>
<h3 class="source-heading simple">Source<span class="source-lang">JS</span></h3>
<pre class="source simple"><code class="language-js">let simpleParent = () =&gt;
  ['div',
    ['p', "I include simpleComponent."],
    [simpleComponent]];</code></pre>

<p>Data is passed to child components using plain old JS data types. Like this:</p>

<h3 class="example-heading">Example<a class="example-hide">hide</a></h3>
<div id="say-hello" class="example simple"><p>Hello, world!</p></div>
<h3 class="source-heading simple">Source<span class="source-lang">JS</span></h3>
<pre class="source simple"><code class="language-js">let helloComponent = (name) =&gt;
  ['p', "Hello, ", name, "!"];

let sayHello = () =&gt;
  [helloComponent, "world"];</code></pre>

<p><strong>Note:</strong> In the example above, <code>helloComponent</code> might just as well have been called as a normal JS function instead of as a Reagent component.
The only difference would have been performance, since ”real” Reagent components are only re-rendered when their data have changed.
More advanced components though (see below) must be called with square brackets.</p>
<p>Here is another example that shows items in a list:</p>

<h3 class="example-heading">Example<a class="example-hide">hide</a></h3>
<div id="lister-user" class="example simple"><div>
  Here is a list:
  <ul>
    <li>Item 0</li>
    <li>Item 1</li>
    <li>Item 2</li>
  </ul>
</div></div>
<h3 class="source-heading simple">Source<span class="source-lang">JS</span></h3>
<pre class="source simple"><code class="language-js">let r = require('mreframe/reagent');
let {range} = require('lodash');

let lister = (items) =&gt;
  ['ul',
    ...items.map(item =&gt;
      r.with({key: item}, ['li', "Item ", item]))];

let listerUser = () =&gt;
  ['div',
    "Here is a list:",
    [lister, range(3)]];</code></pre>

<p><strong>Note:</strong> The <code>r.with({key: item},</code> part above isn’t really necessary in this simple example,
 but attaching a unique key to every item in a dynamically generated list of components is good practice,
 and helps Mithril to improve performance for large lists. (Note: use it either for every list item, or for none.)
The key can be given either (as in this example) as meta-data, or as a <code>key</code> value in the attributes of a tag.
See Mithril <a href="https://mithril.js.org/keys.html" target="_blank">documentation</a> for more info.</p>


<h2 id="managing-state-in-reagent">Managing state in Reagent</h2>
<p>The easiest way to manage state in Reagent is to use Reagent’s own version of
 <a href="https://github.com/LeXofLeviafan/mreframe/blob/main/docs/atom.md" target="_blank"><code>atom</code></a>. It works exactly like the basic one,
 except that it schedules a redraw every time it is changed. Any component that uses a <code>r.atom</code> is automagically re-rendered when its value changes.</p>
<p>Let’s demonstrate that with a simple example:</p>

<h3 class="example-heading">Example<a class="example-hide">hide</a></h3>
<div id="counting-component" class="example simple"><div>
  The atom <code>clickCount</code> has value: 0. <input type="button" value="Click me!"/>
</div></div>
<h3 class="source-heading simple">Source<span class="source-lang">JS</span></h3>
<pre class="source simple"><code class="language-js">let {reagent: r, atom: {deref, swap}} = require('mreframe');

var clickCount = r.atom(0);

let countingComponent = () =&gt;
  ['div',
    "The atom ", ['code', "clickCount"], " has value: ",
    deref(clickCount), ". ",
    ['input', {type: 'button',  value: "Click me!",
               onclick: () =&gt; swap(clickCount, n =&gt; n + 1)}]];</code></pre>

<p>Sometimes you may want to maintain state locally in a component. That is easy to do with a <code>r.atom</code> as well.</p>
<p>Here is an example of that, where we call <code>setTimeout</code> every time the component is rendered to update a counter:</p>

<h3 class="example-heading">Example<a class="example-hide">hide</a></h3>
<div id="timer-component" class="example simple"><div>
  Seconds Elapsed: 0
</div></div>
<h3 class="source-heading simple">Source<span class="source-lang">JS</span></h3>
<pre class="source simple"><code class="language-js">let {reagent: r, atom: {deref, swap}} = require('mreframe');

let timerComponent = () =&gt; {
  let secondsElapsed = r.atom(0);
  return () =&gt; {
    setTimeout(() =&gt; swap(secondsElapsed, n =&gt; n + 1), 1000);
    return ['div', "Seconds Elapsed: ", deref(secondsElapsed)];
  };
};</code></pre>

<p>The previous example also uses another feature of Reagent: a component function can return another function,
 that is used to do the actual rendering. This function is called with the same arguments as the first one.</p>
<p>This allows you to perform some setup of newly created components without resorting to Mithril lifecycle events.</p>
<p>By simply passing a <code>r.atom</code> around you can share state management between components, like this:</p>

<h3 class="example-heading">Example<a class="example-hide">hide</a></h3>
<div id="shared-state" class="example simple"><div>
  <p>The value is now: foo</p>
  <p>Change it here: <input type="text" value="foo"/></p>
</div></div>
<h3 class="source-heading simple">Source<span class="source-lang">JS</span></h3>
<pre class="source simple"><code class="language-js">let {reagent: r, atom: {deref, reset}} = require('mreframe');

let atomInput = (value) =&gt;
  ['input', {type: 'text',  value: deref(value),
             oninput: evt =&gt; reset(value, evt.target.value)}];

let sharedState = () =&gt; {
  let val = r.atom("foo");
  return () =&gt;
    ['div',
      ['p', "The value is now: ", deref(val)],
      ['p', "Change it here: ", [atomInput, val]]];
};</code></pre>



<h2 id="essential-api">Essential API</h2>
<p>Reagent supports most of Mithril API, but there is really only one entry-point that is necessary for most applications: <code>r.render</code>.</p>
<p>It takes two arguments: a component, and a DOM node. For example, splashing the very first example all over the page would look like this:</p>

<h3 class="source-heading simple">Source<span class="source-lang">JS</span></h3>
<pre class="source simple"><code class="language-js">let r = require('mreframe/reagent');

let simpleComponent = () =&gt;
  ['div',
    ['p', "I am a component!"],
    ['p.someclass',
      "I have ", ['strong', "bold"],
      ['span', {style: {color: 'red'}}, " and red "], "text."]];

r.render([simpleComponent], document.body);</code></pre>



<h2 id="putting-it-all-together">Putting it all together</h2>
<p>Here is a slightly less contrived example: a simple BMI calculator.</p>
<p>Data is kept in a single <code>r.atom</code>: a dict with height, weight and BMI as keys.</p>

<h3 class="example-heading">Example<a class="example-hide">hide</a></h3>
<div id="bmi-component" class="example simple"><div>
  <h3>BMI calculator</h3>
  <div>
    Height: 180cm
    <input type="range" min="100" max="220" value="180" style="width:100%"/>
  </div>
  <div>
    Weight: 80kg
    <input type="range" min="30" max="150" value="80" style="width:100%"/>
  </div>
  <div>
    BMI: 24 <span style="color:inherit">normal</span>
    <input type="range" min="10" max="50" value="24.691358024691358" style="width:100%"/>
  </div>
</div></div>
<h3 class="source-heading simple">Source<span class="source-lang">JS</span></h3>
<pre class="source simple"><code class="language-js">let r = require('mreframe/reagent');
let {deref, swap} = require('mreframe/atom');
let {merge, assoc, dissoc, chain} = require('mreframe/util');

let calcBmi = data =&gt; {
  let {height, weight, bmi} = data;
  let h = height / 100;
  return merge(data, (bmi ? {weight: bmi * h * h} : {bmi: weight / (h * h)}));
};

var bmiData = r.atom( calcBmi({height: 180, weight: 80}) );

let slider = (param, value, min, max, invalidates) =&gt;
  ['input', {type: 'range', min, max, value,  // order matters :-(
             style: {width: "100%"},
             oninput: e =&gt; {
               let newValue = parseInt(e.target.value);
               swap(bmiData, data =&gt; chain(data,
                                           [assoc, param, newValue],
                                           [dissoc, invalidates],
                                           calcBmi));
             }}];

let bmiComponent = () =&gt; {
  let {weight, height, bmi} = deref(bmiData);
  let [color, diagnose] = (bmi &lt; 18.5 ? ['orange', "underweight"] :
                           bmi &lt; 25   ? ['inherit', "normal"]     :
                           bmi &lt; 30   ? ['orange', "overweight"]  :
                           ['red', "obese"]);
  return ['div',
           ['h3', "BMI calculator"],
           ['div',
             "Height: ", Math.floor(height), "cm",
             [slider, 'height', height, 100, 220, 'bmi']],
           ['div',
             "Weight: ", Math.floor(weight), "kg",
             [slider, 'weight', weight, 30, 150, 'bmi']],
           ['div',
             "BMI: ", Math.floor(bmi), " ",
             ['span', {style: {color}}, diagnose],
             [slider, 'bmi', bmi, 10, 50, 'weight']]];
};</code></pre>



<h2 id="performance">Performance</h2>
<p>Mithril itself is very fast, and so is Reagent. In fact, Reagent will be even faster than plain Mithril a lot of the time,
 as it automatically prevents rerendering of unchanged components (which are normally the majority).</p>
<p>Mounted components are only re-rendered when their parameters have changed.
The change could come from a deref’ed <code>r.atom</code>, the arguments passed to the component or component <code>r.state</code>.</p>
<p>All of these are checked for changes with <code>identical</code> which is basically only a pointer comparison, so the overhead is very low.
Dicts passed as arguments to components are compared the same way: they are considered equal if all their entries are identical.</p>
<p>All this means that you simply won’t have to care about performance most of the time. Just define your UI however you like – it will be fast enough.</p>
<p>There are a couple of situations that you might have to care about, though. If you give Reagent a big list of components to render,
 you might have to supply all of them with a unique <code>key</code> attribute to speed up rendering (see above).
Also note that anonymous functions are not, in general, equal to each other even if they represent the same code and closure.</p>
<p>But again, in general you should just trust that Mithril and Reagent will be fast enough.
This very page is composed of a single Reagent component with thousands of child components
 (every single parenthesis etc in the code examples is a separate vnode)
 and yet the page can be updated many times every second without taxing the browser the slightest.</p>
<p>Incidentally, this page also uses another Mithril trick: the entire page is pre-rendered using Node, and <code>mithril-node-renderer</code>.
When it is loaded into the browser, Mithril automatically attaches event-handlers to the already present DOM tree.</p>
<p><strong>Note:</strong> Comparing with Mithril perftests (which are mostly testing raw rendering speed),
 mreframe shows a relative slowdown in the direct performance (by up to 4 times);
 however, performance of tests involving re-rendering of unchanged components is improved
 by anywhere from a few to a few dozen times or so depending on the test, due to these components not being recalculated in the first place.</p>


<h2 id="complete-demo">Complete demo</h2>

<h3 class="example-heading">Example<a class="example-hide">hide</a></h3>
<div id="simple-example" class="example simple"><div>
  <h1>Hello world, it is now</h1>
  <div style="color:#f34" class="example-clock">
    02:25:00
  </div>
  <div class="color-input">
    Time color: <input type="text" value="#f34"/>
  </div>
</div></div>
<h3 class="source-heading simple">Source<span class="source-lang">JS</span></h3>
<pre class="source simple"><code class="language-js">let {reagent: r, atom: {deref, reset}} = require('mreframe');

var timer = r.atom(new Date);
var timeColor = r.atom("#f34");


let greeting = (message) =&gt;
  ['h1', message];

let clock = () =&gt; {
  let [timeStr] = deref(timer).toTimeString().split(" ");
  return ['div.example-clock', {style: {color: deref(timeColor)}},
           timeStr];
};

let colorInput = () =&gt;
  ['div.color-input',
    "Time color: ",
    ['input', {type: 'text',  value: deref(timeColor),
               oninput: e =&gt; reset(timeColor, e.target.value)}]];

let simpleExample = () =&gt;
  ['div',
    [greeting, "Hello world, it is now"],
    [clock],
    [colorInput]];


setInterval(() =&gt; reset(timer, new Date), 1000);  // timeUpdater

r.render([simpleExample], document.getElementById('app'));</code></pre>



<h2 id="todomvc">Todomvc</h2>
<p>The obligatory todo list looks roughly like this in Reagent (cheating a little bit by skipping routing and persistence):</p>

<h3 class="example-heading">Example<a class="example-hide">hide</a></h3>
<div id="todo-app" class="example todo-app"><div>
  <section id="todoapp">
    <header id="header">
      <h1>todos</h1>
      <input type="text" value="" id="new-todo" placeholder="What needs to be done?"/>
    </header>
    <div>
      <section id="main">
        <input type="checkbox" checked="" id="toggle-all"/>
        <label for="toggle-all">Mark all as complete</label>
        <ul id="todo-list">
          <li class="completed">
            <div class="view">
              <input type="checkbox" checked="" class="toggle"/>
              <label>Rename Cloact to Reagent</label>
              <button class="destroy"></button>
            </div>
          </li>
          <li class="completed">
            <div class="view">
              <input type="checkbox" checked="" class="toggle"/>
              <label>Add undo demo</label>
              <button class="destroy"></button>
            </div>
          </li>
          <li class="completed">
            <div class="view">
              <input type="checkbox" checked="" class="toggle"/>
              <label>Make all rendering async</label>
              <button class="destroy"></button>
            </div>
          </li>
          <li class="completed">
            <div class="view">
              <input type="checkbox" checked="" class="toggle"/>
              <label>Allow any arguments to component functions</label>
              <button class="destroy"></button>
            </div>
          </li>
        </ul>
      </section>
      <footer id="footer">
        <div>
          <span id="todo-count"><strong>0</strong> items left</span>
          <ul id="filters">
            <li><a class="selected">All</a></li>
            <li><a class="">Active</a></li>
            <li><a class="">Completed</a></li>
          </ul>
          <button id="clear-completed">Clear completed 4</button>
        </div>
      </footer>
    </div>
  </section>
  <footer id="info">
    <p>Double-click to edit a todo</p>
  </footer>
</div></div>
<h3 class="source-heading todo-app">Source<span class="source-lang">JS</span></h3>
<pre class="source todo-app"><code class="language-js">let {reagent: r, atom: {deref, reset, swap},
     util: {identity, dict, entries, vals, getIn,
            assoc, assocIn, dissoc, updateIn}} = require('mreframe');
let {map, filter} = require('lodash');

var todos   = r.atom({});
var counter = r.atom(0);

let addTodo = (text) =&gt; {
  let id = swap(counter, n =&gt; n + 1);
  swap(todos, assoc, id, {id,  title: text,  done: false});
};

let toggle = (id) =&gt; swap(todos, updateIn, [id, 'done'], it =&gt; !it);
let save   = (id, title) =&gt; swap(todos, assocIn, [id, 'title'], title);
let remove = (id) =&gt; swap(todos, dissoc, id);

let mmap        = (o, f, arg) =&gt; dict( f(entries(o), arg) );
let completeAll = v  =&gt; swap(todos, mmap, map,    it =&gt; assocIn(it, [1, 'done'], v));
let clearDone   = () =&gt; swap(todos, mmap, filter, it =&gt; !getIn(it, [1, 'done']));


let todoInput = ({title, onsave, onstop}) =&gt; {
  let val = r.atom(title || "");
  let stop = () =&gt; {reset(val, "");   onstop &amp;&amp; onstop()};
  let save = () =&gt; {let v = deref(val).trim();
                    v &amp;&amp; onsave(v);
                    stop()};
  return ({id, className, placeholder}) =&gt;
    ['input', {type: 'text',  value: deref(val),
               id,  className,  placeholder,
               onblur: save,
               oninput:   e =&gt; reset(val, e.target.value),
               onkeydown: e =&gt; (e.which === 13 ? save() :
                                e.which === 26 ? stop() :
                                null)}];
};

let todoEdit = r.createClass({  // not quite equivalent to the original code
  componentDidMount: ({dom}) =&gt; dom.focus(),
  reagentRender:     params =&gt; [todoInput, params],
});

let todoStats = ({filt, active, done}) =&gt; {
  let attrsFor = name =&gt; ({class: [(name == deref(filt)) &amp;&amp; 'selected'],
                           onclick: () =&gt; reset(filt, name)});
  return ['div',
           ['span#todo-count',
             ['strong', active], " ", (active == 1 ? "item" : "items"), " left"],
           ['ul#filters',
             ['li', ['a', attrsFor('all'),    "All"]],
             ['li', ['a', attrsFor('active'), "Active"]],
             ['li', ['a', attrsFor('done'),   "Completed"]]],
           (done &gt; 0) &amp;&amp;
             ['button#clear-completed', {onclick: clearDone},
                "Clear completed ", done]];
};

let todoItem = () =&gt; {
  let editing = r.atom(false);
  return ({id, done, title}) =&gt;
    ['li', {class: {completed: done,  editing: deref(editing)}},
      ['div.view',
        ['input.toggle', {type: 'checkbox',  checked: done,
                          onchange: () =&gt; toggle(id)}],
        ['label', {ondblclick: () =&gt; reset(editing, true)}, title],
        ['button.destroy', {onclick: () =&gt; remove(id)}]],
      deref(editing) &amp;&amp;
        [todoEdit, {className: 'edit',  title,
                    onsave: it =&gt; save(id, it),
                    onstop: () =&gt; reset(editing, false)}]];
};

let todoApp = () =&gt; {
  let filt = r.atom('all');
  return () =&gt; {
    let items = vals( deref(todos) );
    let done = items.filter(it =&gt; it.done).length;
    let active = items.length - done;
    return ['div',
             ['section#todoapp',
               ['header#header',
                 ['h1', "todos"],
                 [todoInput, {id:          'new-todo',
                              placeholder: "What needs to be done?",
                              onsave:      addTodo}]],
               (items.length &gt; 0) &amp;&amp;
                 ['div',
                   ['section#main',
                     ['input#toggle-all', {type: 'checkbox', checked: (active === 0),
                                           onchange: () =&gt; completeAll(active &gt; 0)}],
                     ['label', {for: 'toggle-all'}, "Mark all as complete"],
                     ['ul#todo-list',
                       ...items.filter(deref(filt) === 'active' ? (it =&gt; !it.done) :
                                       deref(filt) === 'done'   ? (it =&gt; it.done)  :
                                       identity).map(todo =&gt;
                         r.with({key: todo.id}, [todoItem, todo]))]],
                   ['footer#footer',
                     [todoStats, {active, done, filt}]]]],
             ['footer#info',
               ['p', "Double-click to edit a todo"]]];
  };
};


// init
addTodo("Rename Cloact to Reagent");
addTodo("Add undo demo");
addTodo("Make all rendering async");
addTodo("Allow any arguments to component functions");
completeAll(true);

r.render([todoApp], document.getElementById('app'));</code></pre>

</main>
</body></html>
